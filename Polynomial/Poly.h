#pragma once

#include <iostream>


template<typename T> 
class Poly
{
	public:
		//================================================================================================================================================================================================================================================================
		Poly(int n)
		{
			data = new T[n + 1];
			this->n = n + 1;

			for(int i = 0; i < this->n	; i++)
				data[i] = 0;
		}

		Poly(const Poly& poly)
		{

		}

		//================================================================================================================================================================================================================================================================
		T& operator[](int index)
		{
			return data[index];
		}

		//================================================================================================================================================================================================================================================================
		const T& operator[](int index) const
		{
			return data[index];
		}

		//================================================================================================================================================================================================================================================================
		float eval(T value)
		{
			float result = 0 ;

			for(int i = n - 1; i >= 0; i--)
				result = result*value + data[i];

			return result;
		}

		//================================================================================================================================================================================================================================================================
		void view()
		{
			std::cout << std::endl << "P(x) = ";
			for(int i = n-1; i >= 1; i--)
				if(data[i])
					std::cout << data[i] << "x^" << i << " + ";
			std::cout << data[0];
		}

		//================================================================================================================================================================================================================================================================
		friend Poly operator+(const Poly& poly1, const Poly& poly2)
		{
			Poly result(poly1.n > poly2.n ? poly1.n : poly2.n);

			for(int i = 0; i < poly1.n; i++)
				result[i] += poly1[i];

			for(int j = 0; j < poly2.n; j++)
				result[j] += poly2[j];

			return result;
		}

		//================================================================================================================================================================================================================================================================
		friend Poly operator-(const Poly& poly1, const Poly& poly2)
		{
			Poly result(poly1.n > poly2.n ? poly1.n : poly2.n);

			for(int i = 0; i < poly1.n; i++)
				result[i] -= poly1[i];

			for(int j = 0; j < poly2.n; j++)
				result[j] -= poly2[j];

			return result;
		}

		//================================================================================================================================================================================================================================================================
		friend Poly operator*(const Poly& poly1, const Poly& poly2)
		{
			Poly result(poly1.n + poly2.n);

			for(int i = 0; i < poly1.n; i++)
				for(int j = 0; j < poly2.n; j++)
					result[i+j] = poly1[i] * poly2[j];

			return result;
		}

	private:
		int n;
		T* data;
};

